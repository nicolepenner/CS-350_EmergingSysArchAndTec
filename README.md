# CS-350_EmergingSysArchAndTec

###### I have included both uartecho.c (a project where an LED light was turned on and off by keyboard commands) and gpiointerrupt.c (my final project where I created a functioning thermostat) to showcase my skills for programming an embedded system. 

### Summarize the project and what problem it was solving.
The goals of this project were to get a temperature sensor to read the temperature of a room, and have an LED on the embedded system light up when the heat is on. The buttons on the embedded system should be able to increase and decrease temperature. This will serve as the base of a project for SysTec to get into the smart thermostat market in the future. The user should be able to set a initial temperature, and eventually turn the heat or air conditioning on to maintain that set point. The board, or eventually the thermostat should alert the user when it is moving toward the set temperature (LED on), and when it has reached it (LED off). As I said, SysTec wants to break into the smart thermostat market and this project is the first step in that process.  

### What did you do particularly well?
I broke apart the pieces of the code to have a piece that performs each function necessary to make this project possible. I also made sure that the readability of my code and comments were clear and concise so a reader unfamilar with my code would know what each piece is doing. I think my implementation of GPIO was especially successful and I felt confident in it's implementation. My separatio of functions so it could be easily maintainable if one piece needed to be edited it could be easily done.  

### Where could you improve?
I think I would have preferred to have created the documentation of what each piece of code should accomplish so it would have been clearer when I was writing it. I typically write out a plan beforehand and I didn't do it until mid-project when I was struggling a bit. I also wonder if I could have simplified some of my code to have the same functionality. 

### What tools and/or resources are you adding to your support network?
I think I would add some type of smart device link so I could try this out with an actual thermostat. That would be the logical next step, and I know I would have to edit some of my code. I do believe I have a good base for that next step though. I will be able to add my knowledge of Code Composer Studio and all the libraries of functions that were available to us for future projects as well, as I hadn't worked with either before. I am also adding my knowledge of embedded systems and code to control them to my support network as well. 

### What skills from this project will be particularly transferable to other projects and/or course work?
Skills that I will be able to use on other projects is how I learned to read the TI board's documentation of functionality and how to control certain aspects of the embedded system. I also think the coding concepts I have learned will be a great skill to transfer to other projects because it is different then anything I have done before. I think the most valuable skills I learned was being able to think about coding embedded systems, it is different than any type of coding I have done before and I think it'll be helpful for future coding problems and projects that I face. 

###  How did you make this project maintainable, readable, and adaptable?
I kept my code in this project maintainable, readable, and adaptable by doing a few different things. I broke my code into smaller chunks and put their usage in the maon thread. This makes each piece of the code adaptable and maintainable because you can edit the functions as needed, and change their usage without effecting the whole main section of the code. In other words, you can edit separate pieces and functions and it won't effect the other functions of the code. I made this code readable by being thorough in commenting my code, that is not too in depth, so I know what each piece does. This ensures that the pieces of code I think have a certain functionality, if they don't I can go back and fix it. This also ensures that if I am collaborating with other programmers, they understand what each piece of code does. This is a great skill to maintain in the future. 
